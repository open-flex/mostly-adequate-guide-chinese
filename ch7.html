<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>第 7 章: Hindley-Milner 类型签名 | JavaScript 函数式编程指南中文版</title>
    
    <meta name="description" content="">
    
    <link rel="preload" href="/mostly-adequate-guide-chinese/assets/css/0.styles.e373d42e.css" as="style"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/app.e22f068f.js" as="script"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/2.35b03a7f.js" as="script"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/19.8afc0231.js" as="script"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/10.9ff47bf3.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/11.1613d626.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/12.5037078b.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/13.54fbdcfe.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/14.85525b84.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/15.b0675b5a.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/16.44cb92b7.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/17.15cbb2bc.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/18.9af46e61.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/3.c39a0118.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/4.47caff48.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/5.209b7f11.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/6.5b22d12f.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/7.9f81ff05.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/8.95229e13.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/9.2faab3a0.js">
    <link rel="stylesheet" href="/mostly-adequate-guide-chinese/assets/css/0.styles.e373d42e.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JNFKK7VGLS"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-JNFKK7VGLS');
    </script>
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mostly-adequate-guide-chinese/" class="home-link router-link-active"><!----> <span class="site-name">JavaScript 函数式编程指南中文版</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/mostly-adequate-guide-chinese/ch1.html" class="sidebar-link">第 1 章：我们在做什么？</a></li><li><a href="/mostly-adequate-guide-chinese/ch2.html" class="sidebar-link">第 2 章: 一等公民的函数</a></li><li><a href="/mostly-adequate-guide-chinese/ch3.html" class="sidebar-link">第 3 章：纯函数的好处</a></li><li><a href="/mostly-adequate-guide-chinese/ch4.html" class="sidebar-link">第 4 章: 柯里化（curry）</a></li><li><a href="/mostly-adequate-guide-chinese/ch5.html" class="sidebar-link">第 5 章: 代码组合（compose）</a></li><li><a href="/mostly-adequate-guide-chinese/ch6.html" class="sidebar-link">第 6 章: 示例应用</a></li><li><a href="/mostly-adequate-guide-chinese/ch7.html" aria-current="page" class="active sidebar-link">第 7 章: Hindley-Milner 类型签名</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch7.html#初识类型" class="sidebar-link">初识类型</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch7.html#神秘的传奇故事" class="sidebar-link">神秘的传奇故事</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch7.html#缩小可能性范围" class="sidebar-link">缩小可能性范围</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch7.html#自由定理" class="sidebar-link">自由定理</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch7.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/mostly-adequate-guide-chinese/ch8.html" class="sidebar-link">第 8 章: 特百惠</a></li><li><a href="/mostly-adequate-guide-chinese/ch9.html" class="sidebar-link">第 9 章: Monad</a></li><li><a href="/mostly-adequate-guide-chinese/ch10.html" class="sidebar-link">第 10 章：Applicative Functor</a></li><li><a href="/mostly-adequate-guide-chinese/ch11.html" class="sidebar-link">第 11 章：再转换一次，就很自然</a></li><li><a href="/mostly-adequate-guide-chinese/ch12.html" class="sidebar-link">第 12 章：遍历</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第-7-章-hindley-milner-类型签名"><a href="#第-7-章-hindley-milner-类型签名" class="header-anchor">#</a> 第 7 章: Hindley-Milner 类型签名</h1> <h2 id="初识类型"><a href="#初识类型" class="header-anchor">#</a> 初识类型</h2> <p>刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的，本章我们将一起探究下这个系统。</p> <p>类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile time checks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。</p> <p>JavaScript 是一种动态类型语言，但这并不意味着要一味否定类型。我们还是要和字符串、数值、布尔值等等类型打交道的；只不过，语言层面上没有相关的集成让我们时刻谨记各种数据的类型罢了。别担心，既然我们可以用类型签名生成文档，也可以用注释来达到区分类型的目的。</p> <p>JavaScript 也有一些类型检查工具，比如 <a href="http://flowtype.org/" target="_blank" rel="noopener noreferrer">Flow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，或者它的静态类型方言 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。由于本书的目标是让读者能够熟练使用各种工具去书写函数式代码，所以我们将选择所有函数式语言都遵循的标准类型系统。</p> <h2 id="神秘的传奇故事"><a href="#神秘的传奇故事" class="header-anchor">#</a> 神秘的传奇故事</h2> <p>从积尘已久的数学书，到浩如烟海的学术论文；从每周必读的博客文章，到源代码本身，我们都能发现 Hindley-Milner 类型签名的身影。Hindley-Milner 并不是一个复杂的系统，但还是需要一些解释和练习才能完全掌握这个小型语言的要义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  capitalize :: String -&gt; String</span>
<span class="token keyword">var</span> <span class="token function-variable function">capitalize</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token function">head</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token function">tail</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token string">&quot;smurf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//=&gt; &quot;Smurf&quot;</span>
</code></pre></div><p>这里，<code>capitalize</code> 接受一个 <code>String</code> 并返回了一个 <code>String</code>。先别管实现，我们感兴趣的是它的类型签名。</p> <p>在 Hindley-Milner 系统中，函数都写成类似 <code>a -&gt; b</code> 这个样子，其中 <code>a</code> 和<code>b</code> 是任意类型的变量。因此，<code>capitalize</code> 函数的类型签名可以理解为“一个接受 <code>String</code> 返回 <code>String</code> 的函数”。换句话说，它接受一个 <code>String</code> 类型作为输入，并返回一个 <code>String</code> 类型的输出。</p> <p>再来看一些函数签名：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  strLength :: String -&gt; Number</span>
<span class="token keyword">var</span> <span class="token function-variable function">strLength</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//  join :: String -&gt; [String] -&gt; String</span>
<span class="token keyword">var</span> join <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">what<span class="token punctuation">,</span> xs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//  match :: Regex -&gt; String -&gt; [String]</span>
<span class="token keyword">var</span> match <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//  replace :: Regex -&gt; String -&gt; String -&gt; String</span>
<span class="token keyword">var</span> replace <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> sub<span class="token punctuation">,</span> s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>strLength</code> 和 <code>capitalize</code> 类似：接受一个 <code>String</code> 然后返回一个 <code>Number</code>。</p> <p>至于其他的，第一眼看起来可能会比较疑惑。不过在还不完全了解细节的情况下，你尽可以把最后一个类型视作返回值。那么 <code>match</code> 函数就可以这么理解：它接受一个 <code>Regex</code> 和一个 <code>String</code>，返回一个 <code>[String]</code>。但是，这里有一个非常有趣的地方，请允许我稍作解释。</p> <p>对于 <code>match</code> 函数，我们完全可以把它的类型签名这样分组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  match :: Regex -&gt; (String -&gt; [String])</span>
<span class="token keyword">var</span> match <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>是的，把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出 <code>match</code> 这个函数接受一个 <code>Regex</code> 作为参数，返回一个从 <code>String</code> 到 <code>[String]</code> 的函数。因为 curry，造成的结果就是这样：给 <code>match</code> 函数一个 <code>Regex</code>，得到一个新函数，能够处理其 <code>String</code> 参数。当然了，我们并非一定要这么看待这个过程，但这样思考有助于理解为何最后一个类型是返回值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  match :: Regex -&gt; (String -&gt; [String])</span>

<span class="token comment">//  onHoliday :: String -&gt; [String]</span>
<span class="token keyword">var</span> onHoliday <span class="token operator">=</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">holiday</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>每传一个参数，就会弹出类型签名最前面的那个类型。所以 <code>onHoliday</code> 就是已经有了 <code>Regex</code> 参数的 <code>match</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  replace :: Regex -&gt; (String -&gt; (String -&gt; String))</span>
<span class="token keyword">var</span> replace <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> sub<span class="token punctuation">,</span> s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是在这段代码中，就像你看到的那样，为 <code>replace</code> 加上这么多括号未免有些多余。所以这里的括号是完全可以省略的，如果我们愿意，可以一次性把所有的参数都传进来；所以，一种更简单的思路是：<code>replace</code> 接受三个参数，分别是 <code>Regex</code>、<code>String</code> 和另一个 <code>String</code>，返回的还是一个 <code>String</code>。</p> <p>最后几点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  id :: a -&gt; a</span>
<span class="token keyword">var</span> <span class="token function-variable function">id</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">//  map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> xs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的 <code>id</code> 函数接受任意类型的 <code>a</code> 并返回同一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 <code>a</code> 和 <code>b</code> 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的一个原则，所以我们必须重申：<code>a -&gt; b</code> 可以是从任意类型的 <code>a</code> 到任意类型的 <code>b</code>，但是 <code>a -&gt; a</code> 必须是同一个类型。例如，<code>id</code> 可以是 <code>String -&gt; String</code>，也可以是 <code>Number -&gt; Number</code>，但不能是 <code>String -&gt; Bool</code>。</p> <p>相似地，<code>map</code> 也使用了变量，只不过这里的 <code>b</code> 可能与 <code>a</code> 类型相同，也可能不相同。我们可以这么理解：<code>map</code> 接受两个参数，第一个是从任意类型 <code>a</code> 到任意类型 <code>b</code> 的函数；第二个是一个数组，元素是任意类型的 <code>a</code>；<code>map</code> 最后返回的是一个类型 <code>b</code> 的数组。</p> <p>类型签名的美妙令人印象深刻，希望你已经被它深深折服。类型签名简直能够一字一句地告诉我们函数做了什么事情。比如 <code>map</code> 函数就是这样：给定一个从 <code>a</code> 到 <code>b</code> 的函数和一个 <code>a</code> 类型的数组作为参数，它就能返回一个 <code>b</code> 类型的数组。<code>map</code> 唯一的明智之举就是使用其函数参数调用每一个 <code>a</code>，其他所有操作都是噱头。</p> <p>辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。</p> <p>这里还有一些例子，你可以自己试试看能不能理解它们。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  head :: [a] -&gt; a</span>
<span class="token keyword">var</span> <span class="token function-variable function">head</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">xs</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> xs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">//  filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
<span class="token keyword">var</span> filter <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> xs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//  reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span>
<span class="token keyword">var</span> reduce <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> x<span class="token punctuation">,</span> xs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>reduce</code> 可能是以上签名里让人印象最为深刻的一个，同时也是最复杂的一个了，所以如果你理解起来有困难的话，也不必气馁。为了满足你的好奇心，我还是试着解释一下吧；尽管我的解释远远不如你自己通过类型签名理解其含义来得有教益。</p> <p>不保证解释完全正确...（译者注：此处原文是“here goes nothing”，一般用于人们在做没有把握的事情之前说的话。）注意看 <code>reduce</code> 的签名，可以看到它的第一个参数是个函数，这个函数接受一个 <code>b</code> 和一个 <code>a</code> 并返回一个 <code>b</code>。那么这些 <code>a</code> 和 <code>b</code> 是从哪来的呢？很简单，签名中的第二个和第三个参数就是 <code>b</code> 和元素为 <code>a</code> 的数组，所以唯一合理的假设就是这里的 <code>b</code> 和每一个 <code>a</code> 都将传给前面说的函数作为参数。我们还可以看到，<code>reduce</code> 函数最后返回的结果是一个 <code>b</code>，也就是说，<code>reduce</code> 的第一个参数函数的输出就是 <code>reduce</code> 函数的输出。知道了 <code>reduce</code> 的含义，我们才敢说上面关于类型签名的推理是正确的。</p> <h2 id="缩小可能性范围"><a href="#缩小可能性范围" class="header-anchor">#</a> 缩小可能性范围</h2> <p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做 <em>parametricity</em>（http://en.wikipedia.org/wiki/Parametricity ）。这个特性表明，函数将会<em>以一种统一的行为作用于所有的类型</em>。我们来研究下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// head :: [a] -&gt; a</span>
</code></pre></div><p>注意看 <code>head</code>，可以看到它接受 <code>[a]</code> 返回 <code>a</code>。我们除了知道参数是个<code>数组</code>，其他的一概不知；所以函数的功能就只限于操作这个数组上。在它对 <code>a</code> 一无所知的情况下，它可能对 <code>a</code> 做什么操作呢？换句话说，<code>a</code> 告诉我们它不是一个<code>特定</code>的类型，这意味着它可以是<code>任意</code>类型；那么我们的函数对<em>每一个</em>可能的类型的操作都必须保持统一。这就是 <em>parametricity</em> 的含义。要让我们来猜测 <code>head</code> 的实现的话，唯一合理的推断就是它返回数组的第一个，或者最后一个，或者某个随机的元素；当然，<code>head</code> 这个命名应该能给我们一些线索。</p> <p>再看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// reverse :: [a] -&gt; [a]</span>
</code></pre></div><p>仅从类型签名来看，<code>reverse</code> 可能的目的是什么？再次强调，它不能对 <code>a</code> 做任何特定的事情。它不能把 <code>a</code> 变成另一个类型，或者引入一个 <code>b</code>；这都是不可能的。那它可以排序么？答案是不能，没有足够的信息让它去为每一个可能的类型排序。它能重新排列么？可以的，我觉得它可以，但它必须以一种可预料的方式达成目标。另外，它也有可能删除或者重复某一个元素。重点是，不管在哪种情况下，类型 <code>a</code> 的多态性（polymorphism）都会大幅缩小 <code>reverse</code> 函数可能的行为的范围。</p> <p>这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 <a href="https://www.haskell.org/hoogle" target="_blank" rel="noopener noreferrer">Hoogle<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。</p> <h2 id="自由定理"><a href="#自由定理" class="header-anchor">#</a> 自由定理</h2> <p>类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来<em>自由定理</em>（free theorems）。下面是两个直接从 <a href="http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf" target="_blank" rel="noopener noreferrer">Wadler 关于此主题的论文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中随机选择的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// head :: [a] -&gt; a</span>
<span class="token function">compose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span>
<span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不用写一行代码你也能理解这些定理，它们直接来自于类型本身。第一个例子中，等式左边说的是，先获取数组的<code>头部</code>（译者注：即第一个元素），然后对它调用函数 <code>f</code>；等式右边说的是，先对数组中的每一个元素调用 <code>f</code>，然后再取其返回结果的<code>头部</code>。这两个表达式的作用是相等的，但是前者要快得多。</p> <p>你可能会想，这不是常识么。但根据我的调查，计算机是没有常识的。实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。</p> <p>第二个例子 <code>filter</code> 也是一样。等式左边是说，先组合 <code>f</code> 和 <code>p</code> 检查哪些元素要过滤掉，然后再通过 <code>map</code> 实际调用 <code>f</code>（别忘了 <code>filter</code> 是不会改变数组中元素的，这就保证了 <code>a</code> 将保持不变）；等式右边是说，先用 <code>map</code> 调用 <code>f</code>，然后再根据 <code>p</code> 过滤元素。这两者也是相等的。</p> <p>以上只是两个例子，但它们传达的定理却是普适的，可以应用到所有的多态性类型签名上。在 JavaScript 中，你可以借助一些工具来声明重写规则，也可以直接使用 <code>compose</code> 函数来定义重写规则。总之，这么做的好处是显而易见且唾手可得的，可能性则是无限的。</p> <h1 id="类型约束"><a href="#类型约束" class="header-anchor">#</a> 类型约束</h1> <p>最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sort :: Ord a =&gt; [a] -&gt; [a]</span>
</code></pre></div><p>胖箭头左边表明的是这样一个事实：<code>a</code> 一定是个 <code>Ord</code> 对象。也就是说，<code>a</code> 必须要实现 <code>Ord</code> 接口。<code>Ord</code> 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 <code>a</code> 的更多信息，了解 <code>sort</code> 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做<em>类型约束</em>（type constraints）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// assertEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; Assertion</span>
</code></pre></div><p>这个例子中有两个约束：<code>Eq</code> 和 <code>Show</code>。它们保证了我们可以检查不同的 <code>a</code> 是否相等，并在有不相等的情况下打印出其中的差异。</p> <p>我们将会在后面的章节中看到更多类型约束的例子，其含义也会更加清晰。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Hindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更需要花点时间了。从这开始，我们将给每一行代码都加上类型签名。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mostly-adequate-guide-chinese/ch6.html" class="prev">
        第 6 章: 示例应用
      </a></span> <span class="next"><a href="/mostly-adequate-guide-chinese/ch8.html">
        第 8 章: 特百惠
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mostly-adequate-guide-chinese/assets/js/app.e22f068f.js" defer></script><script src="/mostly-adequate-guide-chinese/assets/js/2.35b03a7f.js" defer></script><script src="/mostly-adequate-guide-chinese/assets/js/19.8afc0231.js" defer></script>
  </body>
</html>
