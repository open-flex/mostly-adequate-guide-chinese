<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>第 12 章：遍历 | JavaScript 函数式编程指南中文版</title>
    
    <meta name="description" content="">
    
    <link rel="preload" href="/mostly-adequate-guide-chinese/assets/css/0.styles.e373d42e.css" as="style"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/app.e22f068f.js" as="script"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/2.35b03a7f.js" as="script"><link rel="preload" href="/mostly-adequate-guide-chinese/assets/js/16.44cb92b7.js" as="script"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/10.9ff47bf3.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/11.1613d626.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/12.5037078b.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/13.54fbdcfe.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/14.85525b84.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/15.b0675b5a.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/17.15cbb2bc.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/18.9af46e61.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/19.8afc0231.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/3.c39a0118.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/4.47caff48.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/5.209b7f11.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/6.5b22d12f.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/7.9f81ff05.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/8.95229e13.js"><link rel="prefetch" href="/mostly-adequate-guide-chinese/assets/js/9.2faab3a0.js">
    <link rel="stylesheet" href="/mostly-adequate-guide-chinese/assets/css/0.styles.e373d42e.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JNFKK7VGLS"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-JNFKK7VGLS');
    </script>
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mostly-adequate-guide-chinese/" class="home-link router-link-active"><!----> <span class="site-name">JavaScript 函数式编程指南中文版</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/mostly-adequate-guide-chinese/ch1.html" class="sidebar-link">第 1 章：我们在做什么？</a></li><li><a href="/mostly-adequate-guide-chinese/ch2.html" class="sidebar-link">第 2 章: 一等公民的函数</a></li><li><a href="/mostly-adequate-guide-chinese/ch3.html" class="sidebar-link">第 3 章：纯函数的好处</a></li><li><a href="/mostly-adequate-guide-chinese/ch4.html" class="sidebar-link">第 4 章: 柯里化（curry）</a></li><li><a href="/mostly-adequate-guide-chinese/ch5.html" class="sidebar-link">第 5 章: 代码组合（compose）</a></li><li><a href="/mostly-adequate-guide-chinese/ch6.html" class="sidebar-link">第 6 章: 示例应用</a></li><li><a href="/mostly-adequate-guide-chinese/ch7.html" class="sidebar-link">第 7 章: Hindley-Milner 类型签名</a></li><li><a href="/mostly-adequate-guide-chinese/ch8.html" class="sidebar-link">第 8 章: 特百惠</a></li><li><a href="/mostly-adequate-guide-chinese/ch9.html" class="sidebar-link">第 9 章: Monad</a></li><li><a href="/mostly-adequate-guide-chinese/ch10.html" class="sidebar-link">第 10 章：Applicative Functor</a></li><li><a href="/mostly-adequate-guide-chinese/ch11.html" class="sidebar-link">第 11 章：再转换一次，就很自然</a></li><li><a href="/mostly-adequate-guide-chinese/ch12.html" aria-current="page" class="active sidebar-link">第 12 章：遍历</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#类型与类型" class="sidebar-link">类型与类型</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#类型风水" class="sidebar-link">类型风水</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#作用组合" class="sidebar-link">作用组合</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#类型的华尔兹" class="sidebar-link">类型的华尔兹</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#定律" class="sidebar-link">定律</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/mostly-adequate-guide-chinese/ch12.html#练习" class="sidebar-link">练习</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第-12-章-遍历"><a href="#第-12-章-遍历" class="header-anchor">#</a> 第 12 章：遍历</h1> <p>迄今为止，在我们的容器马戏团中，你曾看到我们驯服了凶猛的 <a href="/mostly-adequate-guide-chinese/ch8.html">functor</a>，让它听从我们的意志，执行任何让我们心动的操作；你曾被同时使用<a href="/mostly-adequate-guide-chinese/ch10.html">函数应用</a>来收集结果的许多危险作用的杂耍弄得晕头转向；你曾在看到容器通过 <a href="/mostly-adequate-guide-chinese/ch9.html">join</a> 凭空消失时惊讶地坐倒。在副作用杂耍中，我们看到它们经过 compose 合为一体。而最近，我们大胆地超越了自然，在你的眼前将一种类型转化为另一种 (<a href="/mostly-adequate-guide-chinese/ch11.html">natural transformations</a>)。</p> <p>至于我们的下一个表演，我们要看一下遍历。我们将看着类型在彼此之间翱翔，就像空中飞人一样保持着我们的值不变。我们将像倾斜旋转中的手推车一样重新排列作用 (effects)。当我们的容器像变形金刚的四肢一样交织在一起时，我们可以用这个接口来进行整理。我们将见证不同的作用与不同的顺序。拿上我的长裤和滑动口哨，让我们开始吧。</p> <h2 id="类型与类型"><a href="#类型与类型" class="header-anchor">#</a> 类型与类型</h2> <p>让我们整点怪活：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// readFile :: FileName -&gt; Task Error String</span>

<span class="token comment">// firstWords :: String -&gt; String</span>
<span class="token keyword">const</span> firstWords <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">intercalate</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// tldr :: FileName -&gt; Task Error String</span>
<span class="token keyword">const</span> tldr <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>firstWords<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">map</span><span class="token punctuation">(</span>tldr<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'file1'</span><span class="token punctuation">,</span> <span class="token string">'file2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [Task('hail the monarchy'), Task('smash the patriarchy')]</span>
</code></pre></div><p>在这里，我们读了一堆文件然后形成一个无用的 task 数组。要怎么样对其中的每一个进行 fork 操作呢？如果我们能够把类型做一些变化，得到 <code>Task Error [String]</code> 而不是 <code>[Task Error String]</code> 的话，想必是极好的。这样，我们将得到一个包含所有结果的 future value（译注：即异步任务完成后返回的值）；从异步的需求来说，这要比多个 future value （分别在各自空闲时间完成任务后再返回）要好操作得多。</p> <p>这里有最后一个例子，展示一种棘手的情况：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// getAttribute :: String -&gt; Node -&gt; Maybe String</span>
<span class="token comment">// $ :: Selector -&gt; IO Node</span>

<span class="token comment">// getControlNode :: Selector -&gt; IO (Maybe (IO Node))</span>
<span class="token keyword">const</span> getControlNode <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'aria-controls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  $
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看看那些渴望在一起的 <code>IO</code> 们。如果能把他们 <code>join</code> 起来，让他们面对面地跳舞，那真是太可爱了。可惜的是，一个 <code>Maybe</code> 站在他们之间，就像舞会上的陪练。我们最好的办法是把它们的位置移到彼此旁边，这样每种类型最后都可以在一起，我们的签名可以简化为 <code>IO (Maybe Node)</code>。</p> <h2 id="类型风水"><a href="#类型风水" class="header-anchor">#</a> 类型风水</h2> <p><code>Traversable</code> 接口由两个值得称道的函数组成：<code>sequence</code> 和 <code>traverse</code>。</p> <p>我们用 <code>sequence</code> 重新编排编排类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">sequence</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span>of<span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'the facts'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Just('the facts')]</span>
<span class="token function">sequence</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> Task<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> Task<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Task(Map({ a: 1, b: 2 }))</span>
<span class="token function">sequence</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span>of<span class="token punctuation">,</span> Either<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'buckle my shoe'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// IO(Right('buckle my shoe'))</span>
<span class="token function">sequence</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token punctuation">[</span>Either<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'wing'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Right(['wing'])</span>
<span class="token function">sequence</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token string">'wing'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Task(Left('wing'))</span>
</code></pre></div><p>看清楚这里发生了什么吗？嵌套类型里外翻转了过来，就像潮湿夏夜里的皮裤翻过来了一样。内部的 functor 转移到了外部，而外部的转移到了内部。不过要注意，<code>sequence</code> 对它的参数有一点挑剔。它看起来像这样子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sequence :: (Traversable t, Applicative f) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)</span>
<span class="token keyword">const</span> sequence <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span><span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span><span class="token function">sequence</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们先看第二个参数。它必须是一个持有 <em>Applicative</em> 的 <em>Traversable</em>。这听起来很严格，但是事实往往如此。这就是把 <code>t (f a)</code> 转换成了 <code>f (t a)</code>。还不够明显吗？这两种类型简直就是在背靠背。而第一个参数，它仅仅是一个拐杖，只在无类型的语言中是必要的。它提供了一个类型构造器（即 <em>of</em>）用来倒置那些不情愿被 map 的类型（比如 <code>Left</code>）——稍后会有更多介绍。</p> <p>使用 <code>sequence</code>，我们可以像在人行道上变戏法一样精确地转移类型。但它是如何工作的呢？让我们看看一个类型，比如说 <code>Either</code>，会如何实现它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Right</span> <span class="token keyword">extends</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">sequence</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span>of<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>没错，如果我们的 <code>$value</code> 是一个 functor （事实上它必须是一个 applicative functor），我们就可以简单地 <code>map</code> 我们的构造器来实现类型的跃迁。</p> <p>你可能注意到，我们把 <code>of</code> 完全忽略掉了。它仅仅是为了在 <code>map</code> 不可用的情况下而被传入的，比如在 <code>Left</code> 中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Left</span> <span class="token keyword">extends</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">sequence</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们希望这些类型总是以相同的排列结束，所以对于像 <code>Left</code> 这样的实际上并不持有 applicative functor 的类型来说，我们有必要这么做来让它们获得一点小小的帮助。 <em>Applicative</em> 接口要求我们首先有一个 <em>Pointed Functor</em>，使得我们总是有一个 <code>of</code> 来传入。在具有类型系统的语言中，外部的类型可以通过签名被推断而不需要显式地给出。</p> <h2 id="作用组合"><a href="#作用组合" class="header-anchor">#</a> 作用组合</h2> <p>就我们的容器而言，不同的顺序会带来不同的结果，如果我有一个 <code>[Maybe a]</code>，它是一个包含可能的值的集合 (a collection of possible values)；而如果我有一个 <code>Maybe [a]</code>，那是一个可能的包含值的集合 (a possible collection of values)。前者表示我们会宽容地保留那些&quot;好&quot;的值，而后者则意味着这是一个 &quot;all or nothing&quot; 的情况。类似地，<code>Either Error (Task Error a)</code> 可以表示一个客户端的验证，而 <code>Task Error (Either Error a)</code> 则会是一个服务端的验证。类型可以互换，为我们带来不同的作用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// fromPredicate :: (a -&gt; Bool) -&gt; a -&gt; Either e a</span>

<span class="token comment">// partition :: (a -&gt; Bool) -&gt; [a] -&gt; [Either e a]</span>
<span class="token keyword">const</span> <span class="token function-variable function">partition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">fromPredicate</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// validate :: (a -&gt; Bool) -&gt; [a] -&gt; Either e [a]</span>
<span class="token keyword">const</span> <span class="token function-variable function">validate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token function">fromPredicate</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里，根据我们使用 <code>map</code> 还是 <code>traverse</code>，我们有两个不同的函数。第一个， <code>partition</code> 将会根据谓词函数给我们一个包含 <code>Left</code> 和 <code>Right</code> 的数组。这能够把宝贵的数据保留起来以供未来使用，而不是将它和洗澡水一同过滤掉。相反，<code>validate</code> 将会给我们一个包含第一个不符合谓词函数的项目的 <code>Left</code>，或者如果一切顺利的话给我们所有的包含对应元素的 <code>Right</code>。通过选择不同的类型顺序，我们得到不同的行为。</p> <p>让我们看看 <code>List</code> 的 <code>traverse</code> 函数，来了解 <code>validate</code> 是如何形成的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span><span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">b</span> <span class="token operator">=&gt;</span> <span class="token parameter">bs</span> <span class="token operator">=&gt;</span> bs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它仅仅是对这个列表运行了一次 <code>reduce</code>。 传入的 reduce 函数是 <code>(f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f)</code>，这看起来有点儿吓人，让我们一步步看。</p> <ol><li><p><code>reduce(..., ...)</code></p> <p>它的签名是 <code>reduce :: [a] -&gt; (f -&gt; a -&gt; f) -&gt; f -&gt; f</code>。第一个参数事实上是由 <code>$value</code> 的点标记提供的，它是一个数组。然后我们需要一个函数，以一个 <code>f</code> (一个累计器) 和一个 a (迭代器，代表当前值) 为输入参数，返回一个新的累计器。</p></li> <li><p><code>of(new List([]))</code></p> <p>reduce 函数的初始值是 <code>of(new List([]))</code>，在我们的例子当中则是 <code>Right([]) :: Either e [a]</code>。注意 <code>Either e [a]</code> 同时也是我们的最终返回类型。</p></li> <li><p><code>fn::Applicative f =&gt; a -&gt; f a</code></p> <p>如果我们把它应用到上面的例子， <code>fn</code> 实际上是 <code>fromPredicate(f) :: a -&gt; Either e a</code></p> <blockquote><p>fn(a) :: Either e a</p></blockquote></li> <li><p><code>.map(b =&gt; bs =&gt; bs.concat(b))</code></p> <p>当 <code>fn(a)</code> 是一个 <code>Right</code> 的时候，<code>Either.map</code> 将正确的值传入函数中并且返回一个包含结果的新的 <code>Right</code>。在这个例子中，函数有一个参数 (<code>b</code>)，并且返回了另一个函数 (<code>bs =&gt; bs.concat(b)</code>，其中 <code>b</code> 由于闭包的存在是在作用域内的。)。当它是一个 <code>Left</code> 时，Left 对应的值会被返回。</p> <blockquote><p>fn(a).map(b =&gt; bs =&gt; bs.concat(b)) :: Either e ([a] -&gt; [a])</p></blockquote></li> <li><p><code>ap(f)</code></p> <p><code>f</code> 在这里是一个 Applicative，所以我们可以把函数 <code>bs =&gt; bs.concat(b)</code> 应用到 <code>f</code> 中任意的值 <code>bs :: [a]</code>。幸运的是，<code>f</code> 是从我们的初始种子得到的，它有这样的类型：<code>f :: Either e [a]</code>，这也会在我们应用 <code>bs =&gt; bs.concat(b)</code> 的时候保留下来。当 <code>f</code> 是 <code>Right</code> 的时候，它将会调用 <code>bs =&gt; bs.concat(b)</code>，返回一个将元素添加到列表中的 <code>Right</code>；当它是个 <code>Left</code> 的时候，Left 对应的值会被返回。</p> <blockquote><p>fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f) :: Either e [a]</p></blockquote></li></ol> <p>这个神奇的转换仅仅通过 <code>List.traverse</code> 中的 6 行简短的代码实现，并且通过 <code>of</code>, <code>map</code> 和 <code>ap</code> 完成，所以它将在任意的 Applicative Functor 中正常工作。这是一个很棒的例子，展示了那些抽象能够如何帮助我们写出高度通用的代码，仅仅依赖于一点点假设（而且这些假设可以通过类型系统声明和检查！）。</p> <h2 id="类型的华尔兹"><a href="#类型的华尔兹" class="header-anchor">#</a> 类型的华尔兹</h2> <p>是时候重新回顾并且清理我们最开始的例子了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// readFile :: FileName -&gt; Task Error String</span>

<span class="token comment">// firstWords :: String -&gt; String</span>
<span class="token keyword">const</span> firstWords <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">intercalate</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// tldr :: FileName -&gt; Task Error String</span>
<span class="token keyword">const</span> tldr <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>firstWords<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">traverse</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>of<span class="token punctuation">,</span> tldr<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'file1'</span><span class="token punctuation">,</span> <span class="token string">'file2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Task(['hail the monarchy', 'smash the patriarchy']);</span>
</code></pre></div><p>使用 <code>traverse</code> 而不是 <code>map</code>，我们成功地将那些不守规矩的 <code>Task</code> 赶到了一个漂亮的、协调的结果数组中。如果你熟悉 <code>Promise.all()</code>，你会发现它们很像；只不过 <code>traverse</code> 并不是个一次性的自定义函数，它适用于任何可遍历的类型。这些数学上的 API 倾向于以一种互操作、可重用的方式捕获我们想做的大部分事情，而不必像单个类库那样为某一类型重新发明这些函数。</p> <p>让我们清理最后一个例子来收尾。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// getAttribute :: String -&gt; Node -&gt; Maybe String</span>
<span class="token comment">// $ :: Selector -&gt; IO Node</span>

<span class="token comment">// getControlNode :: Selector -&gt; IO (Maybe Node)</span>
<span class="token keyword">const</span> getControlNode <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span>of<span class="token punctuation">,</span> $<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'aria-controls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  $
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们用 <code>chain(traverse(IO.of, $))</code>代替 <code>map(map($))</code>，它在映射时反转我们的类型，然后通过 chain 将两个 IO 扁平化。</p> <h2 id="定律"><a href="#定律" class="header-anchor">#</a> 定律</h2> <p>好了，在你要像法官像敲槌子一样下结论关闭本章之前，还是要认识到，这些定律是很受用的法规保证。在我看来，大多数程序架构的目地是对代码加以限制来缩小可能性，最终引导我们找到正确答案。</p> <p>一个没有定律的接口是迂回的。像其他的数学结构一样，为了我们自己的理智，我们必须暴露出属性。这和封装有类似的作用，因为它保护了数据，使我们能够用另一个遵守定律的公民来交换接口。</p> <p>来吧，我们有一些定律要研究。</p> <h3 id="同一律-identity"><a href="#同一律-identity" class="header-anchor">#</a> 同一律 (Identity)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> identity1 <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sequence</span><span class="token punctuation">(</span>Identity<span class="token punctuation">.</span>of<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>Identity<span class="token punctuation">.</span>of<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> identity2 <span class="token operator">=</span> Identity<span class="token punctuation">.</span>of<span class="token punctuation">;</span>

<span class="token comment">// test it out with Right</span>
<span class="token function">identity1</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'stuff'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Identity(Right('stuff'))</span>

<span class="token function">identity2</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'stuff'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Identity(Right('stuff'))</span>
</code></pre></div><p>这应该是很直接的。如果我们把一个 Identity 放在 functor 中，然后用 <code>sequence</code> 把它翻出来，这就和一开始就把它放在外面是一样的。我们选择 <code>Right</code> 作为小白鼠，因为它很容易验证和检查定律。一个任意的 functor 在这里是正常的，然而，在这里使用一个具体的 functor，即定律本身中的 <code>Identity</code>，可能会引起一些人的注意。请记住，一个<a href="/mostly-adequate-guide-chinese/ch5.html#范畴学">范畴</a>是由其对象之间的变形来定义的，这些变形具有关联构成和同一性。当处理 functor 的范畴时，自然变换就是形态，而 <code>Identity</code> 就是，嗯，自身。<code>Identity</code> functor 和 <code>compose</code> 函数一样，都是很基本的定律。好了，关于 <code>Identity</code> 就先到这里，接下来我们看看 <a href="/mostly-adequate-guide-chinese/ch8.html#一点理论">Compose</a> 类型：</p> <h3 id="组合-composition"><a href="#组合-composition" class="header-anchor">#</a> 组合 (Composition)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> comp1 <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sequence</span><span class="token punctuation">(</span>Compose<span class="token punctuation">.</span>of<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>Compose<span class="token punctuation">.</span>of<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">comp2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Fof<span class="token punctuation">,</span> Gof</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token function">compose</span><span class="token punctuation">(</span>Compose<span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">sequence</span><span class="token punctuation">(</span>Gof<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sequence</span><span class="token punctuation">(</span>Fof<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Test it out with some types we have lying around</span>
<span class="token function">comp1</span><span class="token punctuation">(</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Compose(Right([Identity(true)]))</span>

<span class="token function">comp2</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span>of<span class="token punctuation">,</span> Array<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Compose(Right([Identity(true)]))</span>
</code></pre></div><p>这个定律如人们所期望的那样保留了组合：如果我们交换 functor 的组合，我们不应该看到任何意外，因为组合本身就是一个 functor。我们任意地选择了 <code>true</code>、<code>Right</code>、<code>Identity</code> 和 <code>Array</code> 来测试它。像 <a href="https://hackage.haskell.org/package/QuickCheck" target="_blank" rel="noopener noreferrer">quickcheck<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="http://jsverify.github.io/" target="_blank" rel="noopener noreferrer">jsverify<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的库可以通过模糊测试输入来帮助我们测试这个规律。</p> <p>作为上述定律的自然结果，我们能够获得<a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf" target="_blank" rel="noopener noreferrer">融合遍历<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的能力，这从性能的角度来看很不错。</p> <h3 id="自然-naturality"><a href="#自然-naturality" class="header-anchor">#</a> 自然 (Naturality)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">natLaw1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span><span class="token punctuation">,</span> nt</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">compose</span><span class="token punctuation">(</span>nt<span class="token punctuation">,</span> <span class="token function">sequence</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">natLaw2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span><span class="token punctuation">,</span> nt</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sequence</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// test with a random natural transformation and our friendly Identity/Right functors.</span>

<span class="token comment">// maybeToEither :: Maybe a -&gt; Either () a</span>
<span class="token keyword">const</span> <span class="token function-variable function">maybeToEither</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Left</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">natLaw1</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span>of<span class="token punctuation">,</span> maybeToEither<span class="token punctuation">)</span><span class="token punctuation">(</span>Identity<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'barlow one'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Right(Identity('barlow one'))</span>

<span class="token function">natLaw2</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span>of<span class="token punctuation">,</span> maybeToEither<span class="token punctuation">)</span><span class="token punctuation">(</span>Identity<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'barlow one'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Right(Identity('barlow one'))</span>
</code></pre></div><p>这和同一律有点像。如果我们先把类型翻转出来，在外部做一次 natural transformation，那将会和 map 一下 natural transformation 然后再翻转类型得到同样的结果。</p> <p>这个定律的一个自然的结果就是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>of<span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">.</span>of<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token constant">A</span><span class="token punctuation">.</span>of<span class="token punctuation">;</span>
</code></pre></div><p>从性能的角度看，这也是极好的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><em>Traversable</em> 是一个强大的接口，能够让你像有心灵感应的室内设计师一样轻松重新编排类型。我们可以通过不同的顺序达到不同的作用，也可以熨平那些令人讨厌的无法 <code>join</code> 的类型皱纹。接下来，我们将一起欣赏函数式编程乃至于代数学本身最强大的接口之一：<a href="/mostly-adequate-guide-chinese/ch13.html">Monoids</a>。</p> <h2 id="练习"><a href="#练习" class="header-anchor">#</a> 练习</h2> <p>考虑下列元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// httpGet :: Route -&gt; Task Error JSON</span>

<span class="token comment">// routes :: Map Route Route</span>
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string-property property">'/'</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string-property property">'/about'</span><span class="token operator">:</span> <span class="token string">'/about'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用 traversable 接口把 <code>getJsons</code> 的类型签名改成 <code>Map Route Route -&gt; Task Error (Map Route JSON)</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// getJsons :: Map Route Route -&gt; Map Route (Task Error JSON)</span>
<span class="token keyword">const</span> getJsons <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>httpGet<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们现在定义下列校验函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// validate :: Player -&gt; Either String Player</span>
<span class="token keyword">const</span> <span class="token function-variable function">validate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">player</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  player<span class="token punctuation">.</span>name <span class="token operator">?</span> Either<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>player<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token string">'must have name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用 traversable 和 <code>validate</code> 函数，更新 <code>startGame</code> （和它的类型签名），使得只有在所有玩家是有效时才开始游戏。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// startGame :: [Player] -&gt; [Either Error String]</span>
<span class="token keyword">const</span> startGame <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">always</span><span class="token punctuation">(</span><span class="token string">'game started!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>validate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>最终，我们考虑一些文件系统相关的帮助函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// readfile :: String -&gt; String -&gt; Task Error String</span>
<span class="token comment">// readdir :: String -&gt; Task Error [String]</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mostly-adequate-guide-chinese/ch11.html" class="prev">
        第 11 章：再转换一次，就很自然
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mostly-adequate-guide-chinese/assets/js/app.e22f068f.js" defer></script><script src="/mostly-adequate-guide-chinese/assets/js/2.35b03a7f.js" defer></script><script src="/mostly-adequate-guide-chinese/assets/js/16.44cb92b7.js" defer></script>
  </body>
</html>
